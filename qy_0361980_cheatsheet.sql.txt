/*
 * Name: Qichun Yu
 * Date: 2022-04-22
 * Type: Cheatsheet
 * Asgn: SQL Final Project
 */
 
-- MariaDB service

-- Task Manager/Activity Monitor > Processes > 
-- Name or Process Name, "mysqld.exe"
-- collapse -> MariaDB
-- (RIGHT-click) -> Open Services
-- (CLICK) any Services & type "Maria"
-- (DOUBLE-click) to open & see configuration
-- or (RIGHT-click) -> Properties
-- use for restart your MariaDB service (applying configurations)

-- Path to executable:
"C:\Program Files\MariaDB 10.6\bin\mysqld.exe" 
--defaults-file=D:\DB\_DATA\MariaDB_10.6.5\my.ini" 
"MariaDB"

-- Installation directory
C:\Program Files\MariaDB 10.6

-- bin directory
mysqld.exe service  --"MariaDB" Service
mysql.exe service 

-- default-file=
-- parameter, where to point to when MariaDB Service START

-- Data Directory or DATADIR (store all databases) 
-- contains initial administrative databases
D:\DB\_DATA\MariaDB_10.6.5

-- for error messages
LAPTOP-NRBI2B6T.err
-- PID that MariaDB service running
LAPTOP-NRBI2B6T.pid

-- Configuration file (default settings)
D:\DB\_DATA\MariaDB_10.6.5\my.ini
-- or my.cnf on Mac/Lunux
-- datadir, where databases are stored
-- port=3306, default, network connection to DB 
-- buffer_pool_size, RAM allocated to DB service, RAM of computer / 8 
-- Default Server's Character Set: utf8 (standard web character encoding
-- Page Size, default of 16 K 

-- ** ini/cnf configuration settings to take effect, 
-- require restart the "MariaDB" Service
-- (RIGHT-click) -> Restart 
-- must be exact, error->not restart 
-- [F5] to refresh Service list to check if program running

-- back up file 
my.ini_YYYYMMDD.bak


-- System/Environment Variables
-- [START] -> type "system variables" or 
-- "environment variables" -> [ENTER]
-- System Properties > Advanced -> click Environment Variables
-- System Variables -> double click Path Variable ->
-- Edit environment variable -> click New -> add 
C:\Program Files\MariaDB 10.6\bin
-- -> click OK, OK, OK 
-- reopen Command Prompt -> type mysql hit [Enter] 
-- ->Access denied error 

-- ----------------------------------------------------------------------
-- Connecting MySQL CLI and CREATE DATABASE 

-- to open mysql
mysql -u root -p
-- then asks for your password

-- SEMI-COLONS[;]
-- CLI SQL Commands/Queries require 
-- a semi-colon at the end [ ; ] 
-- hit [ENTER] to execute 

-- COMMENTS # vs./**/

-- # Single Line comment
-- # use extra lines if longer than screen so 
-- # about 60 characters

/* multi-line comment, best used 
 at the start of your documents, to identify, 
 your name, student number, course, etc. AND 
 within your code, to block out entire sections 
 of code, while testing scripts, this comment 
 style should be used sparingly */
 
-- what they used to use from Single Line
-- comments

--shows all MariaDB server databases installed 
SHOW DATABASES;

--or can use: 
SHOW SCHEMAS;

-- information_schema store all databases, tables, 
-- columns, keys, indexes, & permissions
-- mysql, database server related info
-- performance_schema and sys, benchmarking performance 

-- puts you into the database
USE database_name;

-- puts you into the information_schema db
USE information_schema;

-- prints database_name you are in
SELECT DATABASE(); 

-- shows db's table listing
SHOW TABLES;


-- describes table columns
DESCRIBE table_name;

-- describes collations table in 
-- information_schema db
DESCRIBE collations;

-- DESCRIBE TABLE
-- outline structure of the table 
-- Type, Data type, eg. char, int
--       Length, (size) 
--       Unsigned, positive int 
-- Null, can contain Null value(Yes), Not Null(No)
-- Key, key column 
-- Default, if Null, then Default value
-- Extra, any extra info 

-- shows collations for charset utf8mb4
SELECT collation_name, character_set_name
FROM collations
WHERE character_set_name='utf8mb4'
ORDER BY collation_name;

-- select query syntax 
SELECT   column_name, column_name2
FROM     table_name
WHERE    1=1
ORDER BY column_name;


--create database syntax
CREATE DATABASE database_name
CHARSET='utf8mb4'
COLLATE='utf8mb4_unicode_ci';

--drops database
DROP DATABASE database_name;

--DROP DATABASE IF EXISTS database_name;
CREATE DATABASE IF NOT EXISTS database_name
CHARSET='utf8mb4'
COLLATE='utf8mb4_unicode_ci';

-- ------------------------------------------------------------------
-- Data Types

-- select the columns, from the table, view, and/or temp result set 
-- WHERE a conditional evaluates to TRUE, ie: 1=1
SELECT   column1, column2 ... , columnN 
FROM     table_view_subquery_temp_result_set 
WHERE    filter_conditional

-- 4 main Datatypes

-- 1) BOOLEAN

--BOOLEAN - TRUE(1),FALSE(0) values
--boolean is a TINYINT(1) or INT(1)
SELECT FALSE AS b0, TRUE AS b1;

--FALSE returns 0 TRUE returns 1
--b0 and b1 are called labels
--the results returned after executing this 
--SQL query are a result set

--using temp result set(trs) in the FROM
--some conditionals in the SELECT
SELECT b0, b1
     , b0=b1, b0<>b1, b0!=b1, b0=b0
     , trs.b1=TRUE
FROM (SELECT FALSE AS b0, TRUE AS b1) trs;

-- temp result set(trs) needs here, table alias FROM trs, 
-- we are calling COLUMNS b0 and b1, 
-- to display them, and compare via:
-- b0=b1 returns 0 as TRUE doesnot = FALSE
-- b0<>b1 returns 1 as TRUE not = FALSE 
-- not equal operatore is either <> or !=
-- b0=b0 returns 1 as b0 compared to itself are equal
-- trs.b1=TRUE, use an alias-column reference, 
-- that calls b1 from trs compare to TRUE, which
-- returns 1, as b1 = TRUE

-- 2)Numbers
-- Integer - INT(4)
-- Decimals - FLOAT(s,p), DOUBLE(s,p)

-- returns for columns, w/ labels-values listed
SELECT 1 AS i1, 2 AS i2
     , 1.0 AS d1, 2.22 AS d2

-- taking this SELECT and using it as a temporary result set
SELECT i1, i2, d1, d2     -- returns: 1, 2, 1.0, 2.22
 , i1<i2                  -- returns 1 as 1<2 is TRUE
 , i1<=d1                 -- returns 1 as 1<=2 is TRUE
 , i1=d1                  -- returns 1 as 1=1.0 is TRUE
 , i1!=d1                 -- returns 1 as 1!=1.0 is FALSE
 , i2>i1                  -- returns 1 as 2>1 is TRUE
 , d2>=i2                 -- returns 1 as 2.22>=2 is TRUE
 , 1.5  BETWEEN i1 AND d2 -- 1<=1.5<=2.22 TRUE
 , 2.22 BETWEEN i1 AND d2 -- 1<=2.22<=2.22 TRUE
 , 3    BETWEEN i1 AND d2 -- 1<=3<=2.22 is FALSE
FROM (SELECT 1 AS i1, 2 AS i2
           , 1.0 AS d1, 2.22 AS d2) trs2;

-- = is equal to
-- < is less than, <= is less than equal to
-- > is greater than, >= is greater than equal to
-- != and <> are not equal to

-- value BETWEEN begin_value AND end_value
-- compares whether the value is within and/or 
-- equals the begin and end values:
-- with i1=1 and d2=2.22
-- 1.5 BETWEEN 1 AND 2.22 is TRUE basically it is
-- the same as 1<=1.5 AND 1.5<=2.22

SELECT i1, d2
  , 1.5 BETWEEN i1 AND d2
  , i1<=1.5 AND 1.5<=d2   -- same as the between
FROM (SELECT 1 AS i1, 2 AS i2
           , 1.0 AS d1, 2.22 AS d2) trs3;

-- column IN(value1, value2 ... , valueN) will
-- return 1 (TRUE) is the column value is 
-- matching a value in the list:
SELECT i1 IN (1,2,3,4)         -- TRUE  1
     , i2 IN (5,6,7,8)         -- FALSE 0
     , d1 IN (1,2,3,4)         -- TRUE  1
     , d2 IN (i1,i2,d1)        -- FALSE 0
FROM (SELECT 1 AS i1, 2 AS i2
           , 1.0 AS d1, 2.22 AS d2) trs4;


-- do mathematics with numbers
--      add    subtr. times  divide modulus
SELECT i1+i2, i1-i2, i1*i2, i1/i2, i1%i2
     , d1+d2, d1-d2, d1*d2, d1/d2, d1%d2
     , i1+d1, i1-d1, i1*d1, i1/d1, i1%d1
FROM (SELECT 1 AS i1, 2 AS i2
           , 1.0 AS d1, 2.22 AS d2) trs5;
-- so we can add(+) subtract(-) multiply(*)
-- divide(/) and modulus(%, returns remainder)

-- 3)Strings(CHAR, VARCHAR,TEXT)
-- single quotes 'stringvalue'

-- VARCHAR(length) is for variable widths
--•	columns with varying or changing widths, such as full_name column
--•	String Function LENGTH(full_name) function will vary
--•	maximum length for the utf8mb4 charset, 
--  would be VARCHAR(191), as indexes for MySQL 
--  are limited to 768 bytes, 768/4 is 192…so 191 is safest.

--  CHAR(length) is fixed width
-- CHAR(10), 10 characters of length allocated
-- 'Hello' is stored as 'Hello     '
-- examples, postal codes'R0H 0H0', 7 characters,
-- examples, SIN number '642 643 644', 11 characters

--  TEXT type is used for content, 
-- like a news article, or additional/historical information,
-- or change log data.

-- simple strings, begins/ends with space
SELECT ' Hi '  AS s1
     , ' Bye ' AS s2;

-- perform several string functions
-- TRIM remove spaces
SELECT s1, s2              -- returns:
    , TRIM(s1), TRIM(s2)   -- 'Hi' 'Bye'
    , LTRIM(s1), LTRIM(s2) -- 'Hi ' 'Bye '
    , RTRIM(s1), RTRIM(s2) -- ' Hi' ' Bye'
    , CONCAT(s1,'and',s2)  -- ' Hi and Bye '
FROM (SELECT ' Hi '  AS s1
           , ' Bye ' AS s2) tsr6;

-- strings when stored in the database, 
-- the values are TRIM'd, no need in storing spaces,
-- CONCAT usually needs to account for spaces

SELECT s1, s2               -- returns:
    , CONCAT(s1,' and ',s2) -- 'Hi and Bye'
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr7;

-- string comparisons and 'H' or 'i' patterns
SELECT s1, s2       -- returns:
  , s1=s2, s1<>s2   -- 0 (FALSE) | 1 (TRUE)
  , s1='Hi'         -- 1
  , s1<>'Bye'       -- 1 
  , s1 LIKE 'H%'    -- 1, % is 0 to many chars
  , s1 LIKE 'H_'    -- 1, _ means must have 1
  , 'H' LIKE 'H%'   -- 1
  , 'Hi' LIKE 'H%'  -- 1
  , ' Hi' LIKE 'H%' -- 0 if pattern ' H%' rtns: 1
  , 'H' LIKE 'H_'   -- 0, means any 1 char after
  , s1 LIKE 'H__'   -- 0, means any 2 chars after
  , s1 LIKE '_i'    -- 1, means any 1 char before
  , s1 LIKE '__i'   -- 0, means any 2 chars bef.
  , s1 LIKE '%i'    -- 1, 0 to many chars bef.
  , s1 LIKE '%%i'   -- 1, but pointless, NEVER DO
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr8;

-- string comparisons and patterns
SELECT s1, s2       --returns:
  , s2='Bye'        -- 1
  , s2!='Hi'        -- 1 
  , s2 LIKE 'B%'    -- 1, % is 0 to many chars
  , s2 LIKE 'B_'    -- 0, _ must have 1 only
  , 'B' LIKE 'B%'   -- 1
  , 'Bye' LIKE 'B%' -- 1
  , ' Bye' LIKE 'B%'-- 0 if pattern ' B%' rtns: 1
  , 'B' LIKE 'B_'   -- 0, means any 1 char after
  , s2 LIKE 'B__'   -- 1, means any 2 chars after
  , s2 LIKE '_e'    -- 0, means any 1 char before
  , s2 LIKE '__e'   -- 1, means any 2 chars bef.
  , s2 LIKE 'B_e'   -- 1, means 1 char in middle
  , s2 LIKE 'B%e'   -- 1, 0 to many chars mid
  , s2 LIKE '_y_'   -- 1, 1 char beg end, y mid
  , s2 LIKE '%y%'   -- 1, chars beg end, y mid
  , 'y' LIKE '%y%'  -- 1, 0 chars beg end, y mid
  , 'y' LIKE '_y_'  -- 0, 1 char beg end, y mid
  , s2 LIKE '%%e'   -- 1, but pointless, NEVER DO
  , s2 LIKE 'B%%'   -- 1, but pointless, NEVER DO
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9;

-- IN and NOT IN comma delimited list
SELECT s1, s2         -- returns:
  , s1 IN('Hi','Bye')      -- 1
  , s2 IN('Hi','Bye')      -- 1 
  , s1 NOT IN('Hi','Bye')  -- 0
  , s2 NOT IN('Hi','Bye')  -- 0 
  , 'Hello' IN('Hi','Bye') -- 0
  , 'Hello' IN(s1,s2)      -- 0
  , 'Hi'    IN(s1,s2)      -- 1
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9;

-- NULL checks 
SELECT s1, s2, s3        -- returns:
  , s1=s3                -- NULL
  , s2<>s3               -- NULL
  , IFNULL(s3,'Hi')      -- Hi
  , s1=IFNULL(s3,'Hi')   -- 1
  , s1=IFNULL(s3,'')     -- 0 - workaround
  , s2<>IFNULL(s3,'')    -- 1 - workaround
  , s3 IS NULL           -- 1
  , s1 IS NOT NULL       -- 1
  , NULL IN (s1,s2,s3)   -- NULL
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2
           , NULL AS s3) tsr9;

-- AND operator, both conditionals must be TRUE
SELECT s1, s2             -- returns:
  , s1='Hi'  AND s2='Bye' -- 1 TRUE+TRUE=TRUE
  , s1='Hi'  AND s2='Hi'  -- 0 TRUE+FALSE=FALSE
  , s1='Bye' AND s2='Bye' -- 0 FALSE+TRUE=FALSE
  , s1='Bye' AND s2='Hi'  -- 0 FALSE+FALSE=FALSE
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9;

-- OR operator, either conditional must be TRUE
SELECT s1, s2            -- returns:
  , s1='Hi'  OR s2='Bye' -- 1 TRUE or TRUE=TRUE
  , s1='Hi'  OR s2='Hi'  -- 1 TRUE or FALSE=TRUE
  , s1='Bye' OR s2='Bye' -- 1 FALSE or TRUE=TRUE
  , s1='Bye' OR s2='Hi'  -- 0 FALSE or FALSE=FALSE
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9;

-- Typically, most of the comparison items are handled in a WHERE clause.  
-- So if the values compared are FALSE, the ROW will not display:

-- row will display
SELECT s1, s2             
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9
WHERE s1='Hi';

-- row will display
SELECT s1, s2             
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9
WHERE s1='Hi' AND s2='Bye';

-- row will not display
SELECT s1, s2             
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9
WHERE s2='Hi' OR s1='Bye';

-- row will display
SELECT s1, s2             
FROM (SELECT 'Hi'  AS s1
           , 'Bye' AS s2) tsr9
WHERE s1 IN ('Hi','Bye') AND s2 LIKE 'B%';


-- 4) Date(DATE, DATETIME, TIME)
-- formats are fixed width and are compared like strings 
-- •DATE: 'YYYY-MM-DD' (zero padded, 10 character date)
-- •TIME: 'HH:MM:SS' (zero padded, 8 char, 24 hour time)
-- •DATETIME: 'YYYY-MM-DD HH:MM:SS' (19 chars)


-- date comparisons
SELECT d1, d2
    , d1<=d2                               -- 1             
    , d1=d2                                -- 0           
    , d1>d2                                -- 0
    , d1='2020-01-01 00:00:00'             -- 1
    , d2='2020-01-01 00:00:00'             -- 0
    , d1 BETWEEN '2019-01-01 00:00:00'
             AND '2022-01-01 00:00:00'     -- 1
    , d1 NOT BETWEEN '2019-01-01 00:00:00'
                 AND '2022-01-01 00:00:00' -- 0
FROM (SELECT '2020-01-01 00:00:00' AS d1
           , '2021-12-31 23:59:59' AS d2) tsr9;

-- NOW with date numeric functions (maths)
SELECT d1
    , QUARTER(d1)     -- Date Quarter           
    , YEAR(d1)        -- Date Year           
    , MONTH(d1)       -- Date Month
    , DAY(d1)         -- Date Day 
    , HOUR(d1)        -- Date Hour 
    , MINUTE(d1)      -- Date Minute 
    , SECOND(d1)      -- Date Second 
    , WEEKDAY(d1)     -- 0 Mon thru 6 Sun
FROM (SELECT NOW() AS d1) tsr9;

-- Add one year to a date
-- SELECT DATEADD(year, 1, '2017/08/25) AS DateAdd;

FROM (SELECT DATE_ADD(NOW(),INTERVAL -2 DAY)AS d1) tsr9;

-- NOW and common string format functions (
-- https://www.w3schools.com/sql/func_mysql_date_format.asp 
SELECT d1
    , MONTHNAME(d1)   -- Date Month
    , DAYNAME(d1)     -- Date Day 
    , DATE_FORMAT(d1,'%a, %D of %b %Y %l:%i %p')
                      -- Date String
FROM (SELECT NOW() AS d1) tsr9;

-- MORE FUNCTIONS:
-- https://www.w3schools.com/sql/sql_ref_mysql.asp 

---------------------------------------------------------------------
-- Create Table 

--CREATE TABLE syntax
--An ALTER TABLE to ADD/DROP/MODIFY table attributes or table column attributes.
CREATE TABLE table_name (
    column1   inttype(size) AUTO_INCREMENT -- PK
  , column2  datatype(size) NULL DEFAULT value
  ...
  , columnN  datatype(size) NULL DEFAULT value
  , PRIMARY KEY(column1)
);

-- table_name -> singular(not 's')
-- tables at least 1 column, relational DB have at least 2 COLUMNS

-- attributes to the main columns in a DB:
-- PRIMARY KEY(PK), INTEGER, AUTO_INCREMENTs, 1st row -> 1
--  - defined after the column definitions
--  - tables only have 1 PK
-- UNIQUE, makes row unique from other rowsperpage#
-- additional columns, supporting attributes for UNIQUE

-- datatype and size, mostly 'strings', numbers, 'date', boolean TRUE or FALSE
-- NULL, no value exists for the column's row
-- DEFAULT, added after the NULL, when insert a row and don't want it to be NULL
-- DEFAULT '' where '' (2 single quotes ['] ) means an empty string, 
-- which to note is different from the value NULL
-- •	NULL does not equal '' or in SQL: NULL<>'' or NULL!=''
-- best to allow NULLs, NOT NULL could cause issues when adding data 

-- syntax for the people table

DROP TABLE IF EXISTS people;
CREATE TABLE IF NOT EXISTS people (
	   p_id      INT(11)      AUTO_INCREMENT #PK
	 , full_name VARCHAR(100) NULL           #UK
   , PRIMARY KEY(p_id)
);

-- view your people table structure mods
DESCRIBE people;

-- verify your table query works
SELECT * FROM people WHERE 1=1;  --returns 0 rows

-- insert syntax
INSERT INTO table_name (column2 ... , columnN)
VALUES                 (value2 ... , valueN);

-- columns inserting must have a corresponding number of VALUES
-- no column 1, AUTO_INCREMENT key for PK 

-- replace Instructor Name and Your Name with 
-- respective values
INSERT INTO people (full_name) VALUES ('Brad Vincelette');
INSERT INTO people (full_name) VALUES ('Qichun Yu');

-- to overwhite data with new id
INSERT INTO people (p_id,full_name) 
      VALUES (3,'Brad Vincelette');
INSERT INTO people (p_id,full_name) 
      VALUES (4,'Qichun Yu');

-- SELECT FROM syntax 
-- DISTINCT, a way to group data into one of each item 
SELECT   column2 ... , columnN 
FROM     table_name 
WHERE    filter_condition AND|OR second_condition
ORDER BY column2 DESC, ...
LIMIT    rowoffset#,rowsperpage#(rpp); --(page# x   rpp#) - rpp# = ro#

-- SELECT to FROM then WHERE then ORDER BY then LIMIT
-- SELECT* -> show all columns 
-- WHERE, condition that must =TRUE 
-- ORDER BY, ascending by defauly, DESC for descending
-- LIMIT, paging your results, if no ORDER BY -> will use default row order
-- •	LIMIT  2; displays beginning 2 rows
-- •	LIMIT  0,10; displays beginning 10 rows 
-- •	LIMIT 10,10; displays beginning at row 10, 10 rows
-- •	LIMIT 20,10; displays beginning at row 20, 10 rows
-- •	for paging, to calculate the row offset: 
--    (page#  x  rpp#) - rpp# = ro#
--    ie: Page 4 with 10 rows:  (4 x 10)-10=30
--    for LIMIT 30,10

-- get all rows
SELECT p_id, full_name
FROM   people
WHERE  1=1;		

-- get all rows, asterisk means all columns
SELECT * FROM people;     

-- get first record
SELECT p_id, full_name
FROM   people
WHERE  p_id=1;

-- show first row, if 2, shows both rows
SELECT p_id, full_name
FROM   people
LIMIT  1;

-- show second record only
SELECT p_id, full_name
FROM   people
LIMIT  1,1;  

-- get your name record 
SELECT p_id, full_name
FROM   people
WHERE  full_name='Qichun Yu';
-- get the instructor name record
SELECT p_id, full_name
FROM   people
WHERE  full_name='Brad Vincelette';

-- get your last name (replace only the Name in 
-- the last name here, leave in the % and space)
SELECT p_id, full_name
FROM   people
WHERE  full_name LIKE '% Yu';



-- 0         1         2          3         4        5
-- 012345678901234567890123456789012345678901234567890123456789
--'Michael Jordan'
-- 1     789   14
--      -1^+1

-- first letter of name
SELECT p_id
, full_name
  , LEFT(full_name,1)
--  , INSTR(full_name,' ')+1
 , SUBSTR(full_name
           , INSTR(full_name, ' ')+1
           , LENGTH(full_name) - INSTR(full_name, ' ')
  )
, LOWER(CONCAT(LEFT(full_name,1)
--  , INSTR(full_name, ' ')+1
    , SUBSTR(full_name
           , INSTR(full_name, ' ')+1 
           , LENGTH(full_name) - INSTR(full_name, ' ')
        )
        , '@boxstore.com'
))        
FROM   people
;

---------------------------------------------------------------------
-- ALTER TABLE

-- ALTER TABLE syntax
ALTER TABLE   table_name 
  ADD COLUMN  column3  datatype(size) nullable
, ADD COLUMN  column4  datatype(size) nullable
...
, ADD COLUMN  columnN  datatype(size) nullable;

ALTER TABLE   table_name 
  MODIFY COLUMN columnN datatype(size) nullable;

ALTER TABLE   table_name 
  DROP COLUMN columnN;
  
-- must update 1 item
-- DEFAULT can be added after nullable 
-- means an empty string 
ADD COLUMN column_name datatype(size) nullable DEFAULT 

-- during build phase, best to allow NULLs 
-- ofrcing NOT NULL could cause issues 
-- Default is allowing NULL 

-- alter people table, to add first_name 
-- last_name columns
ALTER TABLE   people
  ADD COLUMN  first_name VARCHAR(40) NULL
, ADD COLUMN  last_name  VARCHAR(60) NULL; 

-- view your people table structure mods
DESCRIBE people;

-- list instructor and your name rows
SELECT * FROM people WHERE p_id<=2;

-- UPDATE/SET syntax 
UPDATE table_name 
SET    column1=value1
     , column2=value2
     , ...
     , columnN=valueN
WHERE  condition;

-- SET, column want to update and the value 
-- condition, must be TRUE to show rows 

-- Update 1st 2 records of people table 
SELECT p_id, full_name, first_name, last_name
FROM   people
WHERE  p_id <= 2;

UPDATE people 
SET   first_name='Brad'
    , last_name='Vincelette'
WHERE p_id=1;
UPDATE people 
SET   first_name='Qichun'
    , last_name='Yu'
WHERE p_id=2;

-- STRING FUNCTIONS 
-- parsing data, splitting data up, SQL has several functions: 
-- https://www.w3schools.com/sql/sql_ref_mysql.asp 

-- 0        1         2					ruler tens
-- 012345678901234567890					ruler ones
-- 'FirstName LastName'
--  1       ^?^      ^
--          |^|= space position (SP)
--          ? ?      ? = LENGTH - SP
--       SP-1 SP+1            

-- determine the numeric position of the 
-- stringtofind within the stringvalue.
INSTR(stringvalue, stringtofind) = NUMBER

-- determine the position of the space
SELECT full_name
     , INSTR(full_name,' ') AS pos
     , INSTR(full_name,' ')-1 AS first_name_end_pos
     , INSTR(full_name,' ')+1 AS last_name_beg_pos
FROM   people
WHERE  p_id>=3;

-- take any string and parse out from the 
-- starting character number, up to a 
-- certain number of characters.
MID(string, start, length) = STRING

-- get first name, starts at position 1 and ends
-- at space position minus 1 (aka: length of first name)
SELECT full_name
 , INSTR(full_name,' ')-1 AS first_name_end_pos
 , MID(full_name,1,INSTR(full_name,' ')-1) AS first_name
FROM   people
WHERE  p_id>=3;

-- the last name's first letter position is the 
-- space's location plus 1
SELECT full_name
 , MID(full_name,1,INSTR(full_name,' ')-1) AS first_name
 , INSTR(full_name,' ')+1 as last_name_beg
FROM   people
WHERE  p_id>=3;

-- MID function, starting at space plus 1, using 
-- the column's max size as string length
SELECT full_name
 , MID(full_name,1, INSTR(full_name,' ')-1 ) AS first_name
 , MID(full_name, INSTR(full_name,' ')+1 ,100) AS last_name
FROM   people
WHERE  p_id>=3;

-- 100 is the maximum size of the full_name column 
-- could be replaced with: 
LENGTH(full_name)-INSTR(full_name,' ')

-- to get the length of the last_name 
-- added length less space pos for last name length
SELECT full_name
 , MID(full_name,1,INSTR(full_name,' ')-1) AS first_name
 , MID(full_name,INSTR(full_name,' ')+1
                ,LENGTH(full_name)-INSTR(full_name,' ')
   ) AS last_name
FROM   people
WHERE  p_id>=3;

-- updates first_name and last_name by splitting
-- up full_name column
UPDATE people
SET first_name = MID(full_name,1,INSTR(full_name,' ')-1)
   , last_name = MID(full_name,INSTR(full_name,' ')+1
                       ,LENGTH(full_name)-INSTR(full_name,' ')
                 )
WHERE  1=1;
-- ie: first 2 rows:               p_id<=2;
-- ie: after row 2 to the end      p_id>=3;
 
-- verify your changes:
SELECT * FROM people;

-- updates first_name and last_name by splitting
-- up full_name column
UPDATE people
SET first_name = NULL
   , last_name = NULL
WHERE  1=1;

-- always verify your changes:
SELECT * FROM people;

---------------------------------------------------------------------
-- boxstore database create notes

--recreates database, drops and creates
DROP DATABASE IF EXISTS qy_0361980_boxstore;
CREATE DATABASE IF NOT EXISTS qy_0361980_boxstore
CHARSET='utf8mb4'
COLLATE='utf8mb4_unicode_ci';

-- connects you into DATABASE 
USE qy_0361980_boxstore;

-- Create people table
DROP TABLE IF EXISTS people;
CREATE TABLE IF NOT EXISTS people (
	   p_id      INT(11)      AUTO_INCREMENT #PK
	 , full_name VARCHAR(100) NULL           #UK
   , PRIMARY KEY(p_id)
);

-- verify your table query works
SELECT * FROM people WHERE 1=1; 

-- replace Instructor Name and Your Name with 
TRUNCATE TABLE people;
INSERT INTO people (full_name) VALUES ('Brad Vincelette');
INSERT INTO people (full_name) VALUES ('Qichun Yu');

-- verify
SELECT p_id, full_name 
FROM   people 
WHERE  p_id IN(1,2);

SELECT p_id, full_name 
FROM   people 
WHERE  full_name 
       IN('Brad Vincelette','Qichun Yu');

SELECT p_id, full_name 
FROM   people 
WHERE  p_id>0;

SELECT p_id, full_name 
FROM   people 
WHERE  p_id BETWEEN 1 AND 2;

-- gets people id, name with id 1 or 2
SELECT p_id, full_name 
FROM   people 
WHERE  p_id=1 OR p_id=2;

-- DISTINCT

SELECT p_id, full_name 
FROM   people 
-- WHERE  1=1
-- ORDER BY full_name
LIMIT 0,1;

SELECT p_id, full_name 
FROM   people 
-- WHERE  1=1
ORDER BY full_name DESC
LIMIT 1;

-- (page# x rpp#) - rpp# = ro#
     2       1       1   =  1    

SELECT p_id, full_name 
FROM   people 
WHERE  full_name='Brad Vincelette'; 

SELECT p_id, full_name 
FROM   people 
WHERE  full_name='Qichun Yu'; 

-- get your last name (replace only the Name in 
-- the last name here, leave in the % and space)
SELECT p_id, full_name
FROM   people
WHERE  full_name LIKE 'Brad %';

SELECT p_id, full_name
FROM   people
WHERE  full_name LIKE '_% %_';

SELECT p_id, full_name
FROM   people
WHERE  full_name LIKE '_% %_% %_';   -- look for middle name

-- 0         1         2          3         4        5
-- 012345678901234567890123456789012345678901234567890123456789
--'Michael Jordan'
-- 1     789   14
--      -1^+1

-- first letter of name
SELECT p_id
, full_name
  , LEFT(full_name,1)
--  , INSTR(full_name,' ')+1
 , SUBSTR(full_name
           , INSTR(full_name, ' ')+1
           , LENGTH(full_name) - INSTR(full_name, ' ')
  )
, LOWER(CONCAT(LEFT(full_name,1)
--  , INSTR(full_name, ' ')+1
    , SUBSTR(full_name
           , INSTR(full_name, ' ')+1 
           , LENGTH(full_name) - INSTR(full_name, ' ')
        )
        , '@boxstore.com'
))        
FROM   people
;

SELECT p_id 
  , TRIM(full_name)
FROM   people;  

SELECT p_id
  , LOCATE(' ', full_name, LOCATE(' ', full_name)+1)
FROM people;

SELECT p_id, full_name
FROM   people
WHERE full_name  LIKE '%b% %';

SELECT p_id, full_name
FROM   people
WHERE full_name  LIKE '____ %';

SELECT p_id, full_name
FROM   people
WHERE full_name  LIKE 'B% %_';

SELECT p_id 
  , TRIM(full_name)
FROM   people
WHERE full_name='Qichun';  


-- bulk import 10000 people list
SET GLOBAL local_infile=1;
LOAD DATA LOCAL INFILE 'C:/Users/jacks/OneDrive - Red River College/Documents/RRC/COMP-1701_Transferring_Data_to_Databases/_scripts/qy_0361980_boxstore_people-10000.txt'
INTO TABLE people
LINES TERMINATED BY '\r\n'
(full_name);

-- verify number of import
SELECT COUNT(p_id) FROM people;

-- alter people table, to add first_name & last_name
ALTER TABLE   people
  ADD COLUMN  first_name VARCHAR(40) NULL
, ADD COLUMN  last_name  VARCHAR(60) NULL; 

-- full_name: removed double with single spacing, trims end spaces
UPDATE people SET full_name = TRIM(REPLACE(full_name,'  ', ' '));

-- UPDATE people with first name & last name
UPDATE people
SET    first_name = TRIM(LEFT(full_name, INSTR(full_name, ' ')-1))
     , last_name = TRIM(SUBSTR(full_name
                          , INSTR(full_name, ' ')+1
                          , LENGTH(full_name) - INSTR(full_name, ' ')
					             ))
WHERE  1=1;
SELECT * FROM people;

-- alter people table, to drop full_name
ALTER TABLE people DROP COLUMN full_name;

-- get all rows
SELECT * FROM people;

-- ALTER people table to add more columns
ALTER TABLE people
    ADD COLUMN suite_num VARCHAR(10)
  , ADD COLUMN addr VARCHAR(75)
  , ADD COLUMN addr_mailcode VARCHAR(15)
  , ADD COLUMN addr_type_id SMALLINT -- FK
  , ADD COLUMN addr_info TEXT
  , ADD COLUMN tc_id INT -- FK
  , ADD COLUMN delivery_info TEXT
  , ADD COLUMN ph_home VARCHAR(25)
  , ADD COLUMN ph_cell VARCHAR(25)
  , ADD COLUMN ph_work VARCHAR(25)
  , ADD COLUMN ph_work_ext VARCHAR(10)
  , ADD COLUMN email VARCHAR(50)
  , ADD COLUMN password VARCHAR(25)
  , ADD COLUMN user_id INT NOT NULL DEFAULT 2
  , ADD COLUMN date_mod DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
  , ADD COLUMN active BIT NOT NULL DEFAULT 1;
  
-- UPDATE infos to people table
UPDATE people
SET suite_num="88"
  , addr="Heros Street"
  , addr_mailcode="R3T 8T8"
  , addr_type_id=1
  , addr_info="This is a house"
  , tc_id=436
  , delivery_info="Drop to the back, plz"
  , ph_home="2048888888"
  , ph_cell="2049999999"
  , ph_work="2047777777"
  , email="my@email.com"
  , password="123456"
WHERE p_id=2;

-- verify your TABLE query
SELECT p_id, first_name, last_name
	 , suite_num, addr, addr_mailcode, addr_type_id, addr_info, tc_id
	 , ph_home, ph_cell, ph_work, ph_work_ext, email, password
	 , user_id, date_mod, active
FROM people; 

-- Create Table: people_employee 
DROP TABLE IF EXISTS people_employee;
CREATE TABLE IF NOT EXISTS people_employee (
	  pe_id INT AUTO_INCREMENT
	, p_id INT NOT NULL -- FK
	, p_id_mgr INT
	, pe_uri VARCHAR(75)
	, pe_employee_id CHAR(10)
	, pe_hired DATETIME
	, pe_salary DECIMAL(7,2)
	, user_id INT NOT NULL DEFAULT 2
	, date_mod DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
	, active BIT NOT NULL DEFAULT 1
	, PRIMARY KEY(pe_id)
);

TRUNCATE TABLE people_employee;
INSERT INTO people_employee
       (p_id, p_id_mgr, pe_uri, pe_employee_id, pe_hired, pe_salary)
VALUES (1, NULL, "brad-vincelette", "1111100", "2022-01-31", 96200.00)
     , (2, NULL, "qichun-yu-0361980", "0361980", "2022-01-31", 56200.00);

SELECT pe_id, p_id, p_id_mgr, pe_uri, pe_employee_id, pe_hired, pe_salary
	   , user_id, date_mod, active
FROM people_employee;

-- count how many rows in people table
SELECT COUNT(*) FROM people;

-- show different first_name in people table
SELECT DISTINCT first_name
FROM people
LIMIT 10002;

-- see how many first_name is Brady
SELECT first_name, COUNT(first_name)
FROM people
WHERE first_name='Brady'
GROUP BY first_name
ORDER BY COUNT(first_name) DESC
LIMIT 2000;

-- View people who have different names
SELECT DISTINCT first_name, last_name
FROM people
ORDER BY first_name, last_name
LIMIT 10002;

-- Rename country to geo_country
ALTER TABLE country
  RENAME TO geo_country;
SELECT * FROM geo_country; 

-- DELETE unwanted data from towncity table
DELETE FROM geo_towncity 
WHERE tc_id=1;


-- MORE details will be in boxstore.sql file 
-- qy_0361980_boxstore.sql

-- --------------------------------------------------------------- --
-- JOINs

-- JOINs Syntax
SELECT pt.pt_id, st.pt_id
FROM primary_table pt
     JOIN secondary_table st ON pt.pt_id = st.pt_id

SELECT pkt,pkt_id, fkt.pkt_id
FROM primary_key_table pkt
     JOIN foreign_key_table fkt ON pkt.pkt_id = fkt.pkt_id

SELECT fkt.pkt_id, pkt.pkt_id
FROM foreign_key_table fkt
     JOIN primary_key_table pkt ON fkt.pkt_id = pkt.pkt_id

-- JOIN to find matching 
-- people to category, with people's names, and category name
SELECT p.p_id, p.first_name, p.last_name, p.ph_cell
     , pe.pe_id, pe.p_id, pe.pe_uri, pe.pe_salary
     , pc.p_id, pc.cat_id
     , c.cat_id, c.cat_name
FROM people p
     JOIN people_employee pe ON p.p_id = pe.p_id
     JOIN people_category pc ON p.p_id = pc.p_id
     JOIN category c         ON pc.cat_id = c.cat_id;

-- LEFT JOIN to find matching and unmatching
SELECT p.p_id, p.first_name, p.last_name, p.ph_cell
     , pe.pe_id, pe.p_id, pe.pe_uri, pe.pe_salary
     , pc.p_id, pc.cat_id
     , c.cat_id, c.cat_name
FROM people p
     LEFT JOIN people_employee pe ON p.p_id = pe.p_id
     LEFT JOIN people_category pc ON p.p_id = pc.p_id
     LEFT JOIN category c         ON pc.cat_id = c.cat_id
-- WHERE pe.pe_id IS NOT NULL AND pc.pc_id IS NULL
;

-- FULL JOIN (left and right join, with union)
SELECT p.p_id, p.first_name, p.last_name, p.ph_cell
     , pe.pe_id, pe.p_id, pe.pe_uri, pe.pe_salary
     , pc.pc_id, pc.p_id, pc.cat_id
     , c.cat_id, c.cat_name
FROM people p
     LEFT JOIN people_employee pe ON p.p_id = pe.p_id
     LEFT JOIN people_category pc ON p.p_id = pc.p_id
     LEFT JOIN category c         ON pc.cat_id = c.cat_id
UNION
SELECT p.p_id, p.first_name, p.last_name, p.ph_cell
     , pe.pe_id, pe.p_id, pe.pe_uri, pe.pe_salary
     , pc.pc_id, pc.p_id, pc.cat_id
     , c.cat_id, c.cat_name
FROM people p
     RIGHT JOIN people_employee pe ON p.p_id = pe.p_id
     RIGHT JOIN people_category pc ON p.p_id = pc.p_id
     RIGHT JOIN category c         ON pc.cat_id = c.cat_id
WHERE c.cat_id IN (2,3);

-- mysql does not support full join
-- Reason: SQL Error [1064] [42000]: (conn=160) You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'FULL JOIN people_employee pe ON p.p_id = pe.p_id

-- JOIN: people to orders & item
SELECT p.first_name, p.last_name, p.ph_cell
     , o.order_num, o.order_date, o.order_notes, o.o_id
     , i.item_modelno, i.item_name, i.item_price, ip.ip_price
FROM people p
     JOIN orders o       ON p.p_id = o.p_id
     JOIN orders_item oi ON o.o_id = oi.o_id
     JOIN item i         ON oi.i_id = i.i_id
     JOIN item_price ip  ON i.i_id = ip.i_id;

-- orders to item detail
SELECT o.o_id, o.order_num, o.order_date
     , m.man_name
     , i.item_name, i.item_price
     , id.id_label, id.id_detail
     , im.im_desc
FROM orders o
     JOIN orders_item oi ON o.o_id = oi.o_id
     JOIN item i         ON oi.i_id = i.i_id
     JOIN manufacturer m ON i.m_id = m.m_id
     LEFT JOIN item_detail id ON i.i_id = id.i_id
     LEFT JOIN item_meta im   ON i.i_id = im.i_id;
	 
-- JOIN: orders to transactions
UPDATE transactions SET t_amount=260.68 WHERE t_id=1;

SELECT o.order_num, o.order_date, i.item_name, i.item_price * oi.oi_qty
     , tx.t_amount -- 260.68
FROM orders o
     JOIN orders_item oi          ON o.o_id = oi.o_id
     JOIN item i                  ON oi.i_id = i.i_id
     JOIN orders_transactions otx ON o.o_id = otx.o_id
     JOIN transactions tx         ON otx.t_id = tx.t_id;

SELECT o.order_num, o.order_date, i.item_name
     , i.item_price * oi.oi_qty * tax.tax_calc
     , tx.t_amount
FROM orders o
     JOIN orders_item oi          ON o.o_id = oi.o_id
     JOIN item i                  ON oi.i_id = i.i_id
     JOIN orders_transactions otx ON o.o_id = otx.o_id
     JOIN transactions tx         ON otx.t_id = tx.t_id
     JOIN (
           SELECT (SUM(tax_perc)/100)+1 AS tax_calc -- SUBQUERY
           FROM tax t
           WHERE t.tax_end IS NULL AND tax_beg <= NOW()
     ) tax;

-- category parent to child
SELECT c.*
FROM category c;
   
INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy)
VALUES               ('Kitchen', 1, 'kitchen', NULL, 'general')
                   , ('Coffee & Tea', 3, 'coffee-tea', NULL, 'general');

SELECT c0.cat_name, c1.cat_name
FROM category c0
     JOIN category c1 ON c0.cat_id = c1.cat_id_parent
WHERE c0.cat_id_parent IS NULL;

SELECT c0.cat_name, c1.cat_name, c2.cat_name
FROM category c2
     JOIN category c1 ON c2.cat_id_parent = c1.cat_id
     JOIN category c0 ON c1.cat_id_parent = c0.cat_id
WHERE c0.cat_id_parent IS NULL;

-- SELF JOIN  /  RIGHT JOIN
SELECT CONCAT('/categories/', c0.cat_uri, '/', c1.cat_uri, '/', c2.cat_uri, '/', IFNULL(CONCAT(c3.cat_uri,'/'),'') ) AS cat_uri_full
FROM category c3
     RIGHT JOIN category c2 ON c3.cat_id_parent = c2.cat_id
     RIGHT JOIN category c1 ON c2.cat_id_parent = c1.cat_id
     RIGHT JOIN category c0 ON c1.cat_id_parent = c0.cat_id
WHERE c0.cat_id_parent IS NULL AND c0.taxonomy = 'general';

SELECT c0.cat_name, c1.cat_name
FROM category c0
     JOIN category c1 ON c0.cat_id = c1.cat_id_parent
WHERE c0.cat_id_parent IS NULL AND c0.taxonomy = 'general';

-- item thru category
SELECT c0.taxonomy, c0.cat_id, c0.cat_name
     , c1.cat_id_parent, c1.cat_id, c1.cat_name
FROM category c0
     LEFT JOIN category c1 ON c0.cat_id = c1.cat_id_parent
WHERE c0.cat_id_parent IS NULL AND c0.taxonomy = 'general';

-- people thru category
SELECT c0.taxonomy, c0.cat_id, c0.cat_name
     , c1.cat_id_parent, c1.cat_id, c1.cat_name
FROM category c0
     LEFT JOIN category c1 ON c0.cat_id = c1.cat_id_parent
WHERE c0.cat_id_parent IS NULL AND c0.taxonomy = 'departments';

-- category full uri
SELECT c0.taxonomy, c0.cat_id, c0.cat_name
     , c1.cat_id_parent, c1.cat_id, c1.cat_name
     , CONCAT('/categories/', c0.cat_uri, '/', c1.cat_uri, '/') AS cat_uri_full
FROM category c0
     JOIN category c1 ON c0.cat_id = c1.cat_id_parent
WHERE c0.cat_id_parent IS NULL AND c0.taxonomy = 'general';

-- category to people_category/people
SELECT c.cat_id, c.cat_name, c.cat_uri,c.taxonomy
     , pc.pc_id, p.p_id, p.first_name, p.last_name
     , p.addr, p.ph_home
FROM category c
     JOIN people_category pc ON c.cat_id = pc.cat_id
     JOIN people p           ON pc.p_id = p.p_id
WHERE c.taxonomy = 'departments';

-- 040522 class
SELECT c.cat_id, c.cat_name, c.cat_uri
     , pc.pc_id, pc.p_id, pc.cat_id
     , p.p_id, p.first_name, p.last_name
FROM category c
     LEFT JOIN people_category pc ON c.cat_id = pc.cat_id
     LEFT JOIN people p           ON pc.p_id = p.p_id
WHERE c.cat_id IN (2,3);

-- category to item_category/item
SELECT c.cat_id, c.cat_name, c.cat_uri, c.taxonomy
     , i.item_type, i.item_name, i.item_modelno, i.item_barcode
     , i.item_uri, i.item_size, i.item_uom, i.item_price
     , i.image_uri, i.item_status
FROM category c
     JOIN item_category ic ON c.cat_id = ic.cat_id
     JOIN item i           ON ic.i_id = i.i_id
WHERE c.taxonomy = 'general';

-- 040522 class
SELECT c.cat_id, c.cat_name, c.cat_id_parent
     , ic.ic_id, ic.i_id, ic.cat_id
     , i.i_id, i.item_type, i.item_name, i.item_price
FROM category c
     JOIN item_category ic ON c.cat_id = ic.cat_id
     JOIN item i           ON ic.i_id = i.i_id
WHERE c.cat_id >= 8; -- cat_id_parent IN (4,5,6,7)


SELECT c.cat_id, c.cat_name
--     , i.item_price
     , SUM(i.item_price) AS item_price_tot
FROM category c
     JOIN item_category ic ON c.cat_id = ic.cat_id
     JOIN item i           ON ic.i_id = i.i_id
WHERE c.cat_id >= 8
GROUP BY c.cat_id, c.cat_name
HAVING SUM(i.item_price) >= 10000
ORDER BY item_price_tot DESC, c.cat_id, c.cat_name;

-- people to geo info
SELECT p.p_id, p.first_name, p.last_name, p.addr, p.addr_mailcode
     , gat.addr_type, gtc.tc_name, gr.r_name, gr.r_abbr
     , gc.co_name, gc.co_abbr
FROM people p
     JOIN geo_address_type gat ON p.addr_type_id = gat.addr_type_id
     JOIN geo_towncity gtc     ON p.tc_id = gtc.tc_id
     JOIN geo_region gr        ON gtc.r_id = gr.r_id
     JOIN geo_country gc       ON gr.co_id = gc.co_id;

-- manufacturer to geo info
SELECT m.m_id, m.man_name, m.addr, m.addr_mailcode, m.addr_info
     , gat.addr_type, gtc.tc_name, gr.r_name, gr.r_abbr
FROM manufacturer m
     JOIN geo_address_type gat ON m.addr_type_id = gat.addr_type_id
     JOIN geo_towncity gtc     ON m.tc_id = gtc.tc_id
     JOIN geo_region gr        ON gtc.r_id = gr.r_id
     JOIN geo_country gc       ON gr.co_id = gc.co_id;

-- item to manufacture/item detail/category
SELECT i.i_id, i.item_name, m.m_id, m.man_name
     , im.im_desc, ip.ip_price, id.id_label, id.id_detail, c.cat_name
FROM item i
     JOIN manufacturer m        ON i.m_id = m.m_id 
     JOIN item_price ip         ON i.i_id = ip.i_id
     JOIN item_category ic      ON i.i_id = ic.i_id
     LEFT JOIN item_meta im     ON i.i_id = im.i_id
     LEFT JOIN item_detail id   ON i.i_id = id.i_id
     JOIN category c            ON ic.cat_id = c.cat_id
WHERE c.taxonomy='general';

-- orders to transactions
SELECT o.order_num, o.order_date, i.item_name, i.item_price * oi.oi_qty
     , tx.t_amount -- 260.68
FROM orders o
     JOIN orders_item oi          ON o.o_id = oi.o_id
     JOIN item i                  ON oi.i_id = i.i_id
     JOIN orders_transactions otx ON o.o_id = otx.o_id
     JOIN transactions tx         ON otx.t_id = tx.t_id;

-- orders to item/orders/transactions
SELECT o.order_num, o.order_date, i.item_name
     , i.item_price * oi.oi_qty * t.tax_calc
     , tx.t_amount
FROM orders o
     JOIN orders_item oi          ON o.o_id = oi.o_id
     JOIN item i                  ON oi.i_id = i.i_id
     JOIN orders_transactions otx ON o.o_id = otx.o_id
     JOIN transactions tx         ON otx.t_id = tx.t_id
     JOIN (
           SELECT (SUM(tax_perc)/100)+1 AS tax_calc -- SUBQUERY
           FROM tax t
           WHERE t.tax_end IS NULL AND tax_beg <= NOW()
     ) t;

-- rule of thumb:
-- CHAR fields: UPPER CASE fields.
-- VARCHAR fields: Proper Title Cased fields.
-- TEXT fields:  are like sentences and paragraphs, 
--               upper casing for the sentence start and for brand names, 
--               like iPhone, not Iphone.  Like where appropriate.  Think of a news article.
-- DATE fields: YYYY-MM-DD (10 chars length ALWAYS), with 0 padding single digit date entries.  
-- DATETIME fields: YYYY-MM-DD HH:MM:SS and are always 19 characters in length, 
--                 with zero padding for the hour, minute, second fields.
-- FOREIGN KEY columns: for the first batch of INSERTs were to be 1 or 2, 
--                      depending on the context of the data you are attaching to it.

--	phone number: should be like '204-234-4749' 
--	phone extension: 4 digit CHAR like: '3845'
--	addr should be '124 Portage Ave'

-- suite_num: if it’s a house, then NULL, if apartment, building, or warehouse then '906', 
--	all _uri's should have been a lowercased version of the name or product, 
--                   with hyphens instead of spaces.  The image one, 
--                    could be like '/images/products/barista-express.png' 
--                    …no need to include a domain name or https://domainname.com/ to it.


-- BULK IMPORT ------------------------------------------------------
-- PART ONE ---------------------------------------------------------
-- people -----------------------------------------------------------
-- UPDATE with JOIN to derived query

-- used a z__ prefix, to put the table to the very end of the listing
DROP TABLE IF EXISTS z__street;
CREATE TABLE IF NOT EXISTS z__street(street_name VARCHAR(25));

-- inserting street_name records, regex in notepad++
INSERT INTO z__street VALUES('Second Ave');
INSERT INTO z__street VALUES('Third Ave');
INSERT INTO z__street VALUES('First Ave');
INSERT INTO z__street VALUES('Fourth Ave');
INSERT INTO z__street VALUES('Park Blvd');
INSERT INTO z__street VALUES('Fifth Ave');
INSERT INTO z__street VALUES('Main Blvd');
INSERT INTO z__street VALUES('Sixth Ave');
INSERT INTO z__street VALUES('Oak Blvd');
INSERT INTO z__street VALUES('Seventh Ave');
INSERT INTO z__street VALUES('Pine St');
INSERT INTO z__street VALUES('Maple St');
INSERT INTO z__street VALUES('Cedar Blvd');
INSERT INTO z__street VALUES('Eighth Ave');
INSERT INTO z__street VALUES('Elk Blvd');
INSERT INTO z__street VALUES('View Blvd');
INSERT INTO z__street VALUES('Washington Blvd');
INSERT INTO z__street VALUES('Ninth Ave');
INSERT INTO z__street VALUES('Lake St');
INSERT INTO z__street VALUES('Hill Blvd');

SELECT * FROM z__street;

-- bulk more records to geo_address_type
TRUNCATE TABLE geo_address_type;
INSERT INTO geo_address_type (addr_type)
VALUES                       ('House'),('Apartment'),('Building'),('Warehouse');
-- verify keys are 1 thru 4
SELECT * FROM geo_address_type;

-- developing the query
SELECT p.p_id, p.first_name, p.last_name, NULL AS suite_num
       , MIN(
             CONCAT(
                 CASE WHEN RAND() < 0.25 THEN CONVERT(RAND()*100,INT)
                      WHEN RAND() < 0.50 THEN CONVERT(RAND()*1000,INT)
                      WHEN RAND() < 0.75 THEN CONVERT(RAND()*10000,INT)
                                         ELSE CONVERT(RAND()*10,INT) END+10
                 ,' ',zs.street_name
             )
       ) AS addr
       , 'ROH HOH' AS addr_mailcode
       , CASE WHEN RAND() < 0.50 THEN 1 ELSE 2 END AS addr_type_id
       , NULL AS delivery_info
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_home
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_cell
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_work
       , LEFT(CONVERT(RAND()*10000000,INT),4) AS ph_work_ext
       , CONCAT(LOWER(LEFT(p.first_name,1)),LOWER(p.last_name),'@'
           , CASE WHEN RAND() < 0.25 THEN 'google.com'
                  WHEN RAND() < 0.50 THEN 'outlook.com'
                  WHEN RAND() < 0.75 THEN 'live.com'
                                     ELSE 'rocketmail.com' END) AS email
        ,MD5(RAND()) AS password
        ,NOW() AS date_mod
FROM people p, z__street zs
GROUP BY p.p_id, p.first_name, p.last_name;

-- noting password column too short for MD5 32 character hash
ALTER TABLE people MODIFY COLUMN password VARCHAR(32) NULL;

-- massive update of people table (remove first_name, last_name from SELECT and GROUP BY)
UPDATE people p
       JOIN (
       
  SELECT p.p_id
       , MIN(
             CONCAT(
                 CASE WHEN RAND() < 0.25 THEN CONVERT(RAND()*100,INT)
                      WHEN RAND() < 0.50 THEN CONVERT(RAND()*1000,INT)
                      WHEN RAND() < 0.75 THEN CONVERT(RAND()*10000,INT)
                                         ELSE CONVERT(RAND()*10,INT) END+10
                 ,' ',zs.street_name
             )
       ) AS addr
       , 'ROH HOH' AS addr_mailcode
       , CASE WHEN RAND() < 0.50 THEN 1 ELSE 2 END AS addr_type_id
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_home
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_cell
       , CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_work
       , LEFT(CONVERT(RAND()*10000000,INT),4) AS ph_work_ext
       , CONCAT(LOWER(LEFT(p.first_name,1)),LOWER(p.last_name),'@'
           , CASE WHEN RAND() < 0.25 THEN 'google.com'
                  WHEN RAND() < 0.50 THEN 'outlook.com'
                  WHEN RAND() < 0.75 THEN 'live.com'
                                     ELSE 'rocketmail.com' END) AS email
       , MD5(RAND()) AS password
       , NOW() AS date_mod
FROM people p, z__street zs
GROUP BY p.p_id     
       
       ) dt ON p.p_id = dt.p_id
SET p.addr = dt.addr
  , p.addr_mailcode = dt.addr_mailcode
  , p.addr_type_id = dt.addr_type_id
  , p.tc_id = 1
  , p.ph_home = dt.ph_home
  , p.ph_cell = dt.ph_cell
  , p.ph_work = dt.ph_work
  , p.ph_work_ext = dt.ph_work_ext
  , p.email = dt.email
  , p.password = dt.password
  , p.date_mod = dt.date_mod;

UPDATE people p
SET p.ph_home = CONCAT('204-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4))
  , p.date_mod = NOW()
;

-- verify people and geo's
SELECT p.p_id, p.first_name, p.last_name
   , p.suite_num, p.addr, p.addr_mailcode, p.addr_type_id, p.addr_info, p.tc_id
   , p.ph_home, p.ph_cell, p.ph_work, p.ph_work_ext, p.email, p.password
   , p.user_id, p.date_mod, p.active
   , gat.addr_type
   , gtc.tc_name, gr.r_name, gc.co_name 
FROM people p
     JOIN geo_address_type gat ON p.addr_type_id = gat.addr_type_id
     JOIN geo_towncity gtc     ON p.tc_id = gtc.tc_id
     JOIN geo_region gr        ON gtc.r_id = gr.r_id
     JOIN geo_country gc       ON gr.co_id = gc.co_id;

-- turf the z__street table
DROP TABLE IF EXISTS z__street;

-- PART TWO ---------------------------------------------------------
-- geos -------------------------------------------------------------

TRUNCATE TABLE geo_address_type;
INSERT INTO geo_address_type (addr_type)
VALUES                       ('House'),('Apartment'),('Building'),('Warehouse');

TRUNCATE TABLE geo_country;
INSERT INTO geo_country (co_name, co_abbr) VALUES ('Canada', 'CA');                     -- 1
INSERT INTO geo_country (co_name, co_abbr) VALUES ('Japan', 'JP');                      -- 2
INSERT INTO geo_country (co_name, co_abbr) VALUES ('South Korea', 'KR');                -- 3
INSERT INTO geo_country (co_name, co_abbr) VALUES ('United States of America', 'US');   -- 4

SELECT * FROM geo_country;

DESCRIBE geo_country;

SELECT gc.co_id, gc.co_name, gc.co_abbr, gc.active FROM geo_country gc;

ALTER TABLE geo_country ADD COLUMN active BIT NOT NULL DEFAULT 1;

TRUNCATE TABLE geo_region;
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Manitoba', 'MB', 1);            -- 1,1
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Tokyo', NULL, 2);               -- 2,2
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Osaka', NULL, 2);               -- 3,2
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Gyeonggi', NULL, 3);            -- 4,3
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('California', 'CA', 4);          -- 5,4
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Texas', 'TX', 4);               -- 6,4
INSERT INTO geo_region (r_name, r_abbr, co_id) VALUES ('Washington', 'WA', 4);          -- 7,4

SELECT gc.co_name, gr.r_id, gr.r_name, gr.r_abbr, gr.co_id, gr.active
FROM geo_region gr
     JOIN geo_country gc ON gr.co_id=gc.co_id;

TRUNCATE TABLE geo_towncity;
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Winnipeg', 1);                        -- 1,1,1
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Chiyoda', 2);                         -- 2,2,2
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Minato', 2);                          -- 3,2,2
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Kadoma', 3);                          -- 4,3,2
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Suwon', 4);                           -- 5,4,3
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Seoul', 4);                           -- 6,4,3
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Lost Altos', 5);                      -- 7,5,4
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Santa Clara', 5);                     -- 8,5,4
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Round Rock', 6);                      -- 9,6,4
INSERT INTO geo_towncity (tc_name, r_id) VALUES ('Redmond', 7);                         -- 10,7,4

SELECT gtc.tc_id, gtc.tc_name, gtc.r_id, gtc.active FROM geo_towncity gtc;

SELECT gc.co_id, gc.co_name, gr.r_id, gr.r_name, gtc.tc_id, gtc.tc_name
FROM geo_towncity gtc
   JOIN geo_region gr ON gtc.r_id=gr.r_id 
   JOIN geo_country gc ON gr.co_id=gc.co_id;

-- manufacturers ----------------------------------------------------
INSERT INTO manufacturer (m_id, man_name, addr, addr_mailcode, addr_type_id, addr_info, tc_id)
VALUES (2 ,'Apple Inc.'         ,'260-17 First St','PO Box: 26017',3,NULL,7)
      ,(3 ,'Samsung Electronics','221-6 Second St','PO Box: 24355',3,NULL,5)
      ,(4 ,'Dell Technologies'  ,'90-62 Third St' ,'PO Box: 26017',3,NULL,9)
      ,(5 ,'Hitachi'            ,'88-42 Fourth St','PO Box: 26017',3,NULL,2)
      ,(6 ,'Sony'               ,'80-92 Fifth St' ,'PO Box: 26017',3,NULL,3)
      ,(7 ,'Panasonic'          ,'74-73 Sixth St' ,'PO Box: 26017',3,NULL,4)
      ,(8 ,'Intel'              ,'71-9 Seventh St','PO Box: 26017',3,NULL,8)
      ,(9 ,'LG Electronics'     ,'54-39 Eighth St','PO Box: 26017',3,NULL,6)
      ,(10,'Microsoft'          ,'100-10 Ninth St','PO Box: 26017',3,NULL,10);

SELECT m_id, man_name, addr, addr_mailcode, addr_type_id, addr_info, tc_id
FROM manufacturer;
 
UPDATE manufacturer m0 JOIN (
  SELECT m_id
       , CONCAT('800-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_main
       , CONCAT('855-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_sales
       , LEFT(CONVERT(RAND()*10000000,INT),4) AS ph_sales_ext
       , CONCAT('888-', LEFT(CONVERT(RAND()*10000000,INT),3),'-', LEFT(CONVERT(RAND()*10000000,INT),4)) AS ph_inv
  FROM manufacturer m
) m1 ON m0.m_id=m1.m_id
SET m0.ph_main=m1.ph_main
  , m0.ph_sales=m1.ph_sales
  , m0.ph_sales_ext=m1.ph_sales_ext
  , m0.ph_inv=m1.ph_inv;

SELECT m_id, ph_main, ph_sales, ph_sales_ext, ph_inv
FROM manufacturer;

SELECT m.m_id, m.man_name, gc.co_id, gc.co_name, gr.r_id, gr.r_name, gtc.tc_id, gtc.tc_name
FROM manufacturer m
   JOIN geo_towncity gtc ON m.tc_id=gtc.tc_id
   JOIN geo_region gr ON gtc.r_id=gr.r_id 
   JOIN geo_country gc ON gr.co_id=gc.co_id
ORDER BY gc.co_name, gr.r_name, gtc.tc_name, m.m_id;

-- PART THREE -------------------------------------------------------
-- categories -------------------------------------------------------
DESCRIBE category;
TRUNCATE TABLE category;

-- departments > people --------------------------------------------------
INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy) -- 1
VALUES               ('Staff', NULL, 'staff', NULL, 'departments');

INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy) -- 2
VALUES               ('Sales', 1, 'sales', NULL, 'departments');

INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy) -- 3
VALUES               ('Warehouse', 1, 'warehouse', NULL, 'departments');

-- general > item --------------------------------------------------
INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy) -- 4,5,6,7
VALUES  ('Televisions', NULL,'televisions', 'TV', 'general')
      , ('Portable Electronics', NULL,'portable-electronics', 'PE', 'general')
      , ('Kitchen Appliances', NULL,'kitchen-appliances', 'KA', 'general')
      , ('Large Appliances', NULL,'large-appliances', 'LA', 'general');

-- item subcategories
INSERT INTO category (cat_name, cat_id_parent, cat_uri, cat_abbr, taxonomy) -- 8 thru 16
VALUES   ('70" & Up',4,'70-up',NULL,'general')
       , ('60" - 69"',4,'60-69',NULL,'general')
       , ('55" & Down',4,'55-down',NULL,'general')
       , ('Smartphones',5,'smartphones',NULL,'general')
       , ('Tablets',5,'tablets',NULL,'general')
       , ('Blender',6,'blender',NULL,'general')
       , ('Coffee & Tea',6,'coffee-tea',NULL,'general') -- 14
       , ('Washer',7,'washer',NULL,'general')
       , ('Dryer',7,'dryer',NULL,'general');

SELECT * 
FROM category
WHERE taxonomy='departments';

SELECT CONCAT('/categories/',IFNULL(CONCAT(c0.cat_uri,'/'),''),IFNULL(CONCAT(c1.cat_uri,'/'),'')) AS cat_uri_full
      , c0.cat_name, c1.cat_name
FROM category c1
     JOIN category c0 ON c1.cat_id_parent = c0.cat_id
WHERE c0.taxonomy = 'general';

-- RUN THESE ONLY ONCE!!! -------------------------------------------

-- switches the items' category to Coffee & Tea (assuming you 
-- entered the Barista Express coffee maker example, so change from cat_id 2 to 14)
UPDATE item_category   SET cat_id=14 WHERE cat_id=2;

-- switches the people's category to Sales (which gets reloaded from cat_id 1 to 2)
UPDATE people_category SET cat_id=2 WHERE cat_id=1;   

-- ------------------------------------------------------------------

-- 04012022
-- checks for bad FK values
SELECT p.p_id, pc.p_id, pc.cat_id, c.cat_id
FROM people p 
     RIGHT JOIN people_category pc ON p.p_id=pc.p_id
     RIGHT JOIN (SELECT * FROM category c0 WHERE c0.taxonomy='departments' AND c0.cat_id_parent IS NOT NULL) c
          ON pc.cat_id=c.cat_id
UNION
SELECT p.p_id, pc.p_id, pc.cat_id, c.cat_id
FROM people p 
     LEFT JOIN people_category pc ON p.p_id=pc.p_id
     LEFT JOIN (SELECT * FROM category c0 WHERE c0.taxonomy='departments' AND c0.cat_id_parent IS NOT NULL) c
          ON pc.cat_id=c.cat_id;

-- example
-- checks for bad FK values
SELECT p.p_id, pc.p_id, pc.cat_id, c.cat_id
FROM people p 
     RIGHT JOIN people_category pc ON p.p_id=pc.p_id
     RIGHT JOIN (SELECT * FROM category c0 WHERE c0.taxonomy='departments' AND c0.cat_id_parent IS NOT NULL) c
          ON pc.cat_id=c.cat_id
UNION
SELECT p.p_id, pc.p_id, pc.cat_id, c.cat_id
FROM people p 
     LEFT JOIN people_category pc ON p.p_id=pc.p_id
     LEFT JOIN (SELECT * FROM category c0 WHERE c0.taxonomy='departments' AND c0.cat_id_parent IS NOT NULL) c
          ON pc.cat_id=c.cat_id;

-- randoms ----------------------------------------------------------
SELECT CASE WHEN RAND() < 0.25 THEN CONVERT(RAND()*100,INT)
            WHEN RAND() < 0.50 THEN CONVERT(RAND()*1000,INT)
            WHEN RAND() < 0.75 THEN CONVERT(RAND()*10000,INT)
                               ELSE CONVERT(RAND()*10,INT) END;
-- INTEGER FROM 1 to 20
SELECT CONVERT(FLOOR(1 + RAND() * (20 - 1 + 1)),INT)
;

-- random number: value between 0 and 1, ie: 0.123, 0.01232, 0.9999
SELECT RAND();

-- making it bigger than 1 (by multiplying by 100), converting to int and 
-- adding 10 if returned value is 0
SELECT CONVERT(RAND()*100,INT)+10; 

-- item INSERT ------------------------------------------------------
DELETE FROM item WHERE i_id>1;
INSERT INTO item  (item_type, item_name, item_modelno, item_barcode
                  , item_uri, item_size, item_uom, item_price
                  , image_uri, item_status, m_id)
SELECT item_type, CONCAT(m.man_name,' - ',item_name_new), item_modelno, item_barcode
       , NULL, 1, 'Unit', item_price
       , NULL, 'Available', z.m_id
FROM z__orders_items_csv z JOIN manufacturer m ON z.m_id=m.m_id
GROUP BY item_type, CONCAT(m.man_name,' - ',item_name_new), item_modelno, item_barcode, item_price, m_id;


SELECT * FROM item;

-- item_category INSERT ---------------------------------------------
DELETE FROM item_category WHERE i_id>1;
INSERT INTO item_category (i_id, cat_id)
SELECT i.i_id, z.cat_id
FROM z__orders_items_csv z 
    JOIN manufacturer m ON z.m_id=m.m_id
  JOIN item i ON i.item_modelno=z.item_modelno
GROUP BY i.i_id, z.cat_id;

SELECT * FROM item_category;

-- orders INSERT ----------------------------------------------------
DELETE FROM orders WHERE o_id>1;
INSERT INTO orders  (o_id, order_num, order_date, order_notes
                    , order_credit, order_cr_uom, p_id)
SELECT (l.order_num_interv*numlist.p_id)+z.order_num AS o_id
     , (l.order_num_interv*numlist.p_id)+z.order_num AS order_num
     , DATE_ADD(z.order_date, INTERVAL ((-numlist.p_id)/2)+1 DAY) AS order_date_new
     , NULL
     , 0, '$'
   , CONVERT(FLOOR(1 + RAND() * (l.p_id_lmt - 1 + 1)),INT) AS p_id_rnd
FROM z__orders_items_csv z
  JOIN manufacturer m ON z.m_id=m.m_id
  JOIN item i ON i.item_modelno=z.item_modelno
  JOIN (
    SELECT 10002 AS p_id_lmt
       , 10000 AS order_num_interv
       , -100 AS od_val 
  ) l
  , (SELECT p_id-1 AS p_id FROM people ORDER BY p_id) numlist
GROUP BY (l.order_num_interv*numlist.p_id)+z.order_num
  , DATE_ADD(z.order_date, INTERVAL ((-numlist.p_id)/2)+1 DAY), l.p_id_lmt, l.order_num_interv, l.od_val;

SELECT * FROM orders;

-- orders_item INSERT -----------------------------------------------
DELETE FROM orders_item WHERE o_id>1;
INSERT INTO orders_item  (o_id, i_id, oi_return_date, oi_status
                         , oi_qty, oi_override)
SELECT o.o_id, i.i_id, NULL, 'Sold', z.order_qty, 0
FROM z__orders_items_csv z 
    JOIN manufacturer m ON z.m_id=m.m_id
  JOIN item i ON i.item_modelno=z.item_modelno
  JOIN orders o ON RIGHT(o.o_id,4)=z.order_num
GROUP BY o.o_id, i.i_id, z.order_qty;


SELECT * FROM orders_item;

/*Table structure for table `z__orders_items_csv` */

DROP TABLE IF EXISTS `z__orders_items_csv`;

CREATE TABLE `z__orders_items_csv` (
  `m_id` INT(11) DEFAULT NULL,
  `order_num` INT(11) DEFAULT NULL,
  `order_date` DATE DEFAULT NULL,
  `item_type` VARCHAR(8) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `item_modelno` VARCHAR(16) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `item_barcode` INT(11) DEFAULT NULL,
  `cat_name` VARCHAR(16) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `cat_id` INT(11) DEFAULT NULL,
  `item_name_new` VARCHAR(32) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `order_qty` INT(11) DEFAULT NULL,
  `item_price` DECIMAL(7,2) DEFAULT NULL,
  `extra` VARCHAR(8) COLLATE utf8mb4_unicode_ci DEFAULT NULL
) ENGINE=INNODB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

/*Data for the table `z__orders_items_csv` */

INSERT  INTO `z__orders_items_csv`(`m_id`,`order_num`,`order_date`,`item_type`,`item_modelno`,`item_barcode`,`cat_name`,`cat_id`,`item_name_new`,`order_qty`,`item_price`,`extra`) VALUES 
(6,1160,'2021-05-18','product','6PRI0299999203',99999203,'55\" & Down',10,'50\" HDTV',3,2100.00,'6PRI02'),
(10,1026,'2021-01-13','product','2BRE1100066001',66001,'55\" & Down',10,'50\" HDTV',2,2100.00,'2BRE11'),
(10,1057,'2021-01-18','product','2BRE1000056014',56014,'55\" & Down',10,'50\" HDTV',2,2605.00,'2BRE10'),
(4,1091,'2021-02-17','product','3FPT0100051287',51287,'60\" - 69\"',9,'65\" HDTV',4,6065.33,'3FPT01'),
(4,1091,'2021-02-17','product','3FPT0100051281',51281,'60\" - 69\"',9,'65\" HDTV',1,6665.33,'3FPT01'),
(4,1091,'2021-02-17','product','3FPT0100051286',51286,'60\" - 69\"',9,'65\" HDTV',1,6665.33,'3FPT01'),
(5,1060,'2021-01-18','product','6LID0100051166',51166,'60\" - 69\"',9,'65\" HDTV',2,5502.67,'6LID01'),
(9,1174,'2021-05-19','product','2SUR1100056001',56001,'60\" - 69\"',9,'65\" HDTV',3,5000.00,'2SUR11'),
(6,1160,'2021-05-18','product','6PRI0299999197',99999197,'70\" & Up',8,'75\" HDTV',2,20013.33,'6PRI02'),
(6,1160,'2021-05-18','product','6PRI0299999198',99999198,'70\" & Up',8,'75\" HDTV',2,20013.33,'6PRI02'),
(4,1044,'2021-01-18','product','3SKY0111164009',11164009,'Blender',13,'20 ounce Blender',3,69.53,'3SKY01'),
(4,1044,'2021-01-18','product','3SKY0142542001',42542001,'Blender',13,'20 ounce Blender',3,89.41,'3SKY01'),
(5,1021,'2021-01-13','product','4MAR0120815001',20815001,'Blender',13,'20 ounce Blender',3,54.35,'4MAR01'),
(6,1254,'2022-01-28','product','4SOD0100001009',1009,'Blender',13,'20 ounce Blender',5,89.00,'4SOD01'),
(8,1040,'2021-01-18','product','2SUR1108413009',8413009,'Blender',13,'20 ounce Blender',3,50.75,'2SUR11'),
(1,1003,'2021-01-13','product','1GQD0200001006',1006,'Coffee & Tea',14,'Barista Express',2,100.00,'1GQD02'),
(1,1180,'2021-05-20','product','1GQD0200001006',1006,'Coffee & Tea',14,'Barista Express',1,100.00,'1GQD02'),
(1,1239,'2021-01-13','product','1GQD0200001006',1006,'Coffee & Tea',14,'Barista Express',1,100.00,'1GQD02'),
(1,1030,'2021-01-13','product','1GQD0200001012',1012,'Coffee & Tea',14,'Barista Express',1,133.17,'1GQD02'),
(2,1173,'2021-05-18','product','7BOC0244563001',44563001,'Coffee & Tea',14,'Barista Express',4,199.80,'7BOC02'),
(3,1151,'2021-04-28','product','3BRI0300001012',1012,'Coffee & Tea',14,'Barista Express',3,133.17,'3BRI03'),
(5,1195,'2021-05-24','product','4HEL0141994001',41994001,'Coffee & Tea',14,'Barista Express',3,124.38,'4HEL01'),
(5,1054,'2021-01-18','product','4HEL0140182001',40182001,'Coffee & Tea',14,'Barista Express',3,172.63,'4HEL01'),
(7,1031,'2021-01-14','product','7SPP0105618009',5618009,'Coffee & Tea',14,'Barista Express',4,199.80,'7SPP01'),
(8,1040,'2021-01-18','product','2SUR1103820009',3820009,'Coffee & Tea',14,'Barista Express',1,104.50,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1115323121',15323121,'Coffee & Tea',14,'Barista Express',1,144.18,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1115384001',15384001,'Coffee & Tea',14,'Barista Express',3,152.74,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1115199001',15199001,'Coffee & Tea',14,'Barista Express',3,174.05,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1104929009',4929009,'Coffee & Tea',14,'Barista Express',2,184.80,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1108718009',8718009,'Coffee & Tea',14,'Barista Express',3,189.61,'2SUR11'),
(8,1040,'2021-01-18','product','2SUR1108255009',8255009,'Coffee & Tea',14,'Barista Express',3,196.60,'2SUR11'),
(5,1049,'2021-01-18','product','7HAN0200008359',8359,'Dryer',16,'Dryer',1,710.00,'7HAN02'),
(5,1117,'2021-03-04','product','7HYU0200008359',8359,'Dryer',16,'Dryer',1,710.00,'7HYU02'),
(5,1119,'2021-03-04','product','7SMS0100008359',8359,'Dryer',16,'Dryer',1,710.00,'7SMS01'),
(5,1228,'2021-01-15','product','7SPP0100008359',8359,'Dryer',16,'Dryer',1,710.00,'7SPP01'),
(7,1229,'2021-02-23','product','7SPP0100041409',41409,'Dryer',16,'Dryer',4,716.67,'7SPP01'),
(10,1225,'2020-01-28','product','2BRE1500012590',12590,'Dryer',16,'Dryer',2,666.67,'2BRE15'),
(10,1225,'2020-01-28','product','2BRE1400012576',12576,'Dryer',16,'Dryer',2,783.33,'2BRE14'),
(1,1120,'2021-03-04','product','1GQD0240880001',40880001,'Smartphones',11,'Actually a Flipper',5,238.06,'1GQD02'),
(2,1173,'2021-05-18','product','7BOC0200002293',2293,'Smartphones',11,'Actually a Flipper',3,207.79,'7BOC02'),
(2,1168,'2021-05-18','product','4DAI0200002260',2260,'Smartphones',11,'Actually a Flipper',3,264.74,'4DAI02'),
(3,1137,'2021-04-06','product','3BRI0400002124',2124,'Smartphones',11,'Not-as Smartphone',3,358.74,'3BRI04'),
(3,1046,'2021-01-18','product','7DAE0400012490',12490,'Smartphones',11,'Really Smartphone',4,1250.00,'7DAE04'),
(4,1048,'2021-01-18','product','3TEC0350864001',50864001,'Smartphones',11,'Really Smartphone',1,1090.91,'3TEC03'),
(5,1054,'2021-01-18','product','4HEL0140184001',40184001,'Smartphones',11,'Actually a Flipper',5,226.07,'4HEL01'),
(5,1049,'2021-01-18','product','7HAN0200013563',13563,'Smartphones',11,'Really Smartphone',2,1170.00,'7HAN02'),
(6,1254,'2022-01-28','product','4SOD0100001011',1011,'Smartphones',11,'Actually a Flipper',2,299.70,'4SOD01'),
(6,1160,'2021-05-18','product','6PRI0299999177',99999177,'Smartphones',11,'Not-as Smartphone',3,332.97,'6PRI02'),
(6,1160,'2021-05-18','product','6PRI0299999178',99999178,'Smartphones',11,'Really Smartphone',2,1333.33,'6PRI02'),
(7,1031,'2021-01-14','product','7SPP0120983041',20983041,'Smartphones',11,'Not-as Smartphone',4,332.97,'7SPP01'),
(7,1031,'2021-01-14','product','7SPP0120983081',20983081,'Smartphones',11,'Not-as Smartphone',1,332.97,'7SPP01'),
(8,1040,'2021-01-18','product','2SUR1106484009',6484009,'Smartphones',11,'Not-as Smartphone',3,321.23,'2SUR11'),
(8,1201,'2021-05-24','product','2SUR1199999114',99999114,'Smartphones',11,'Not-as Smartphone',1,363.64,'2SUR11'),
(8,1043,'2021-01-18','product','2SUR1101100321',1100321,'Smartphones',11,'Really Smartphone',3,1272.00,'2SUR11'),
(8,1178,'2021-05-20','product','2SUR1101100321',1100321,'Smartphones',11,'Really Smartphone',4,1272.00,'2SUR11'),
(9,1114,'2021-03-08','product','2SUR1100002124',2124,'Smartphones',11,'Not-as Smartphone',3,358.74,'2SUR11'),
(9,1042,'2021-01-18','product','2SUR1151463001',51463001,'Smartphones',11,'Really Smartphone',1,1040.00,'2SUR11'),
(9,1111,'2021-02-26','product','2SUR1100041398',41398,'Smartphones',11,'Really Smartphone',5,1200.00,'2SUR11'),
(10,1089,'2021-02-24','product','2BRE1200002124',2124,'Smartphones',11,'Not-as Smartphone',3,358.74,'2BRE12'),
(10,1242,'2021-06-09','product','2BRE1600013212',13212,'Smartphones',11,'Really Smartphone',3,1000.00,'2BRE16'),
(10,1033,'2021-01-14','product','2BRE0100008427',8427,'Smartphones',11,'Really Smartphone',1,1010.00,'2BRE01'),
(10,1036,'2021-01-18','product','2BRE0200008427',8427,'Smartphones',11,'Really Smartphone',1,1010.00,'2BRE02'),
(10,1225,'2020-01-28','product','2BRE1300008427',8427,'Smartphones',11,'Really Smartphone',1,1010.00,'2BRE13'),
(10,1058,'2021-01-18','product','2BRE0600013628',13628,'Smartphones',11,'Really Smartphone',3,1350.00,'2BRE06'),
(10,1157,'2021-05-17','product','2BRE0700013628',13628,'Smartphones',11,'Really Smartphone',5,1350.00,'2BRE07'),
(10,1177,'2021-05-20','product','2BRE0900013628',13628,'Smartphones',11,'Really Smartphone',3,1350.00,'2BRE09'),
(1,1046,'2021-01-18','product','1GQD0200008335',8335,'Tablets',12,'Super Tablet',4,1435.00,'1GQD02'),
(1,1090,'2021-02-24','product','3ADA0100008360',8360,'Tablets',12,'Super Tablet',4,2000.00,'3ADA01'),
(2,1170,'2021-05-18','product','4DAI0200002136',2136,'Tablets',12,'Mini Tablet',3,374.63,'4DAI02'),
(2,1211,'2021-05-26','product','4DAI0200002136',2136,'Tablets',12,'Mini Tablet',3,374.63,'4DAI02'),
(2,1171,'2021-05-18','product','4DAI0200002123',2123,'Tablets',12,'Mini Tablet',3,424.58,'4DAI02'),
(3,1169,'2021-05-18','product','3BRI0400002136',2136,'Tablets',12,'Mini Tablet',3,374.63,'3BRI04'),
(3,1111,'2021-02-26','product','7DAE0400008335',8335,'Tablets',12,'Super Tablet',1,1435.00,'7DAE04'),
(4,1105,'2021-02-26','product','3OCE0108211010',8211010,'Tablets',12,'Mini Tablet',3,499.50,'3OCE01'),
(4,1182,'2021-05-20','product','7UNI0400008355',8355,'Tablets',12,'Super Tablet',5,1435.00,'7UNI04'),
(5,1054,'2021-01-18','product','4HEL0105850009',5850009,'Tablets',12,'Mini Tablet',2,448.25,'4HEL01'),
(5,1031,'2021-01-14','product','7HYU0200041406',41406,'Tablets',12,'Super Tablet',4,1500.00,'7HYU02'),
(6,1052,'2021-01-18','product','7SAK0100008355',8355,'Tablets',12,'Super Tablet',3,1435.00,'7SAK01'),
(6,1117,'2021-03-04','product','7SMS0100041406',41406,'Tablets',12,'Super Tablet',4,1500.00,'7SMS01'),
(7,1119,'2021-03-04','product','7SPP0100041406',41406,'Tablets',12,'Super Tablet',4,1500.00,'7SPP01'),
(7,1228,'2021-01-15','product','7SPP0100041406',41406,'Tablets',12,'Super Tablet',4,1500.00,'7SPP01'),
(8,1150,'2021-04-27','product','2SUR1100008294',8294,'Tablets',12,'Super Tablet',3,1414.11,'2SUR11'),
(9,1102,'2021-02-26','product','2SUR1100002136',2136,'Tablets',12,'Mini Tablet',3,374.63,'2SUR11'),
(9,1107,'2021-03-05','product','2SUR1100002136',2136,'Tablets',12,'Mini Tablet',3,374.63,'2SUR11'),
(9,1102,'2021-02-26','product','2SUR1100002137',2137,'Tablets',12,'Mini Tablet',3,394.61,'2SUR11'),
(9,1107,'2021-03-05','product','2SUR1100002137',2137,'Tablets',12,'Mini Tablet',3,394.61,'2SUR11'),
(9,1102,'2021-02-26','product','2SUR1100002143',2143,'Tablets',12,'Mini Tablet',3,419.58,'2SUR11'),
(9,1107,'2021-03-05','product','2SUR1100002143',2143,'Tablets',12,'Mini Tablet',3,419.58,'2SUR11'),
(9,1064,'2021-01-19','product','2SUR1100008335',8335,'Tablets',12,'Super Tablet',5,1435.00,'2SUR11'),
(9,1056,'2021-01-18','product','2SUR1100011577',11577,'Tablets',12,'Super Tablet',1,1842.00,'2SUR11'),
(10,1056,'2021-01-18','product','2SUR1100041491',41491,'Tablets',12,'Super Tablet',1,1991.00,'2SUR11'),
(1,1090,'2021-02-24','product','3ADA0100004335',4335,'Washer',15,'Washer',5,500.00,'3ADA01'),
(3,1034,'2021-01-14','product','3BRI3505804084',5804084,'Washer',15,'Washer',3,504.69,'3BRI35'),
(3,1051,'2021-01-18','product','3DAE0106096009',6096009,'Washer',15,'Washer',3,553.95,'3DAE01');


SELECT * FROM `z__orders_items_csv`;

-- transactions INSERT ----------------------------------------------
DESCRIBE transactions; 
SELECT * FROM transactions;

-- building the insert to transactions
SELECT -- o.o_id, o.p_id, o.order_num, 
        CONVERT(FLOOR(1 + RAND() * (100000000000 - 1 + 1)),INT)             AS t_num
      , o.order_date                                                        AS t_date
      , 'Visa'                                                              AS t_mid
      , CONCAT('2',CONVERT(FLOOR(1 + RAND() * (100000000000 - 1 + 1)),INT)) AS t_acct
      , 'CR'                                                                AS t_type
      , ROUND(    SUM(oi.oi_qty*i.item_price)*t.tax_calc    ,2)             AS t_amount_sum
      , o.o_id                                                              AS user_id
      , tx.t_amount
FROM orders o
     LEFT JOIN orders_transactions otx ON o.o_id = otx.o_id
     LEFT JOIN transactions tx         ON tx.t_id = otx.t_id
     JOIN orders_item oi               ON o.o_id = oi.o_id
     JOIN item i                       ON i.i_id = oi.i_id
     , (
         SELECT (SUM(tax_perc)/100)+1 AS tax_calc
         FROM tax t
         WHERE t.tax_end IS NULL AND tax_beg <= NOW()
     ) t
WHERE tx.t_id IS NULL
GROUP BY o.o_id, o.order_date, t.tax_calc -- , o.p_id, o.order_num, tx.t_amount
ORDER BY t_amount_sum DESC, o.o_id
-- LIMIT 0,1
;

-- 580116 rows inserted ---------------------------------------------
INSERT INTO transactions (t_num, t_date, t_mid, t_acct, t_type, t_amount, user_id)
SELECT CONVERT(FLOOR(1 + RAND() * (100000000000 - 1 + 1)),INT)             AS t_num
     , o.order_date                                                        AS t_date
     , 'Visa'                                                              AS t_mid
     , CONCAT('2',CONVERT(FLOOR(1 + RAND() * (100000000000 - 1 + 1)),INT)) AS t_acct
     , 'CR'                                                                AS t_type
     , ROUND(    SUM(oi.oi_qty*i.item_price)*t.tax_calc    ,2)             AS t_amount
     , o.o_id                                                              AS user_id
      -- , tx.t_amount
FROM orders o
     LEFT JOIN orders_transactions otx ON o.o_id = otx.o_id
     LEFT JOIN transactions tx         ON tx.t_id = otx.t_id
     JOIN orders_item oi               ON o.o_id = oi.o_id
     JOIN item i                       ON i.i_id = oi.i_id
     , (
         SELECT (SUM(tax_perc)/100)+1 AS tax_calc
         FROM tax t
         WHERE t.tax_end IS NULL AND tax_beg <= NOW()
     ) t
WHERE tx.t_id IS NULL -- 1 that FIRST insert
GROUP BY o.o_id, o.order_date, t.tax_calc -- , o.p_id, o.order_num, tx.t_amount
ORDER BY o.o_id;

-- orders_transactions INSERT ---------------------------------------------
DESCRIBE orders_transactions; 
SELECT * FROM orders_transactions;

-- build query
SELECT t.t_id, t.user_id, o.o_id, o.p_id 
FROM transactions t
     JOIN orders o ON t.user_id=o.o_id
WHERE o_id<>1;

-- 580116 rows inserted
INSERT INTO orders_transactions (o_id, t_id, p_id)
SELECT o.o_id, t.t_id, o.p_id 
FROM transactions t
     JOIN orders o ON t.user_id=o.o_id
WHERE o_id<>1;

-- verify
SELECT ot_id, o_id, t_id, p_id
FROM orders_transactions otx;

-- return user_id=2 from being temp o_id stored field
UPDATE transactions SET user_id=2;
SELECT user_id FROM transactions WHERE user_id<>2;

-- transactions SELECT (completed) ----------------------------------
SELECT tx.t_id, tx.t_num, tx.t_date, tx.t_mid, tx.t_acct, tx.t_type, tx.t_amount, tx.user_id
       , o.o_id, o.p_id, o.order_num -- , i.i_id, i.item_name
FROM orders o
     JOIN orders_transactions otx ON o.o_id = otx.o_id
     JOIN transactions tx         ON tx.t_id = otx.t_id
     -- JOIN orders_item oi          ON o.o_id = oi.o_id
     -- JOIN item i                  ON i.i_id = oi.i_id
ORDER BY o.o_id
LIMIT 0, 100;


-- AGGREGATE QUERIES ------------------------------------------------

-- COUNT # of item, totel item_price, averge price, max & min price
DESCRIBE item;

SELECT COUNT(i_id), SUM(item_price)
  , AVG(item_price), SUM(item_price)/COUNT(i_id)
  , MAX(item_price), MIN(item_price)
FROM item;

SELECT i_id, item_uri, i.*
FROM item i;

SELECT COUNT(*) FROM item;

SELECT COUNT(*), COUNT(i_id), COUNT(item_uri)
FROM item;

UPDATE item SET item_type=LOWER(item_type);
SELECT i_id, item_uri, i.*
FROM item i;

-- show distinct first_name
SELECT DISTINCT first_name
FROM people
ORDER BY first_name;

-- count distinct first name
SELECT COUNT(DISTINCT first_name) AS first_name_dst_cnt
FROM   people;

-- /commentary/guest-articles/more-than-just-sdg-12-how-circular-economy-can-bring-holistic-wellbeing/

--  1234567890123456789012345678901234567890
--  Aidan

-- count number of same first name higher or equal to 10
SELECT first_name, COUNT(first_name) AS first_name_cnt
FROM people
WHERE SUBSTR(first_name,2,1) = 'i'
GROUP BY first_name
HAVING COUNT(first_name)>=10
ORDER BY first_name_cnt DESC, first_name;

-- count number of orders
SELECT COUNT(*) FROM orders; -- 580117

-- count number of order from different people
SELECT o.p_id
     , COUNT(o.o_id) AS orders_cnt
     , SUM(i.item_price*oi.oi_qty) AS order_subtot
FROM orders o 
     JOIN orders_item oi ON o.o_id=oi.o_id
     JOIN item i         ON oi.i_id=i.i_id
GROUP BY o.p_id;

-- CONSTRAINT -----------------------------------------------------

-- FOREIGN KEY FK

-- people_employee pe ----------------
-- pe_p_id
ALTER TABLE people_employee DROP CONSTRAINT pe_p_id_FK;

ALTER TABLE people_employee
ADD CONSTRAINT pe_p_id_FK FOREIGN KEY (p_id) REFERENCES people(p_id);

-- pe_p_id_mgr
ALTER TABLE people_employee DROP CONSTRAINT pe_p_id_mgr_FK;
ALTER TABLE people_employee
ADD CONSTRAINT pe_p_id_mgr_FK FOREIGN KEY (p_id_mgr) REFERENCES people(p_id);

-- people p --------------------------
-- addr_type_id
ALTER TABLE people DROP CONSTRAINT p_addr_type_id_FK;

ALTER TABLE people
ADD CONSTRAINT p_addr_type_id_FK FOREIGN KEY (addr_type_id) REFERENCES geo_address_type(addr_type_id);

-- tc_id
ALTER TABLE people DROP CONSTRAINT p_tc_id_FK;

ALTER TABLE people
ADD CONSTRAINT p_tc_id_FK FOREIGN KEY (tc_id) REFERENCES geo_towncity(tc_id);

-- user_id
ALTER TABLE people DROP CONSTRAINT p_user_id_FK;

ALTER TABLE people
ADD CONSTRAINT p_user_id_FK FOREIGN KEY (user_id) REFERENCES people(p_id);

-- people_category pc ------------------
-- p_id
ALTER TABLE people_category DROP CONSTRAINT pc_p_id_FK;

ALTER TABLE people_category
ADD CONSTRAINT pc_p_id_FK FOREIGN KEY (p_id) REFERENCES people(p_id);

-- cat_id
ALTER TABLE people_category DROP CONSTRAINT pc_cat_id_FK;

ALTER TABLE people_category
ADD CONSTRAINT pc_cat_id_FK FOREIGN KEY (cat_id) REFERENCES category(cat_id);

-- category c -------------------------
-- cat_id_parent
ALTER TABLE category DROP CONSTRAINT c_cat_id_parent_FK;

ALTER TABLE category
ADD CONSTRAINT c_cat_id_parent_FK FOREIGN KEY (cat_id_parent) REFERENCES category(cat_id);

-- item_category ic ---------------------
-- i_id
ALTER TABLE item_category DROP CONSTRAINT ic_i_id_FK;

ALTER TABLE item_category
ADD CONSTRAINT ic_i_id_FK FOREIGN KEY (i_id) REFERENCES item(i_id);

-- cat_id
ALTER TABLE item_category DROP CONSTRAINT ic_cat_id_FK;

ALTER TABLE item_category
ADD CONSTRAINT ic_cat_id_FK FOREIGN KEY (cat_id) REFERENCES category(cat_id);

-- geo_towncity gtc --------------------
-- r_id
ALTER TABLE geo_towncity DROP CONSTRAINT gtc_r_id_FK;

ALTER TABLE geo_towncity
ADD CONSTRAINT gtc_r_id_FK FOREIGN KEY (r_id) REFERENCES geo_region(r_id);

-- geo_region gr -----------------------
-- co_id
ALTER TABLE geo_region DROP CONSTRAINT gr_co_id_FK;

ALTER TABLE geo_region
ADD CONSTRAINT gr_co_id_FK FOREIGN KEY (co_id) REFERENCES geo_country(co_id);

-- manufacturer m ----------------------
-- addr_type_id
ALTER TABLE manufacturer DROP CONSTRAINT m_addr_type_id_FK;

ALTER TABLE manufacturer
ADD CONSTRAINT m_addr_type_id_FK FOREIGN KEY (addr_type_id) REFERENCES geo_address_type(addr_type_id);

-- tc_id
ALTER TABLE manufacturer DROP CONSTRAINT m_tc_id_FK;

ALTER TABLE manufacturer
ADD CONSTRAINT m_tc_id_FK FOREIGN KEY (tc_id) REFERENCES geo_towncity(tc_id);

-- item i --------------------------------
-- m_id
ALTER TABLE item DROP CONSTRAINT i_m_id_FK;

ALTER TABLE item
ADD CONSTRAINT i_m_id_FK FOREIGN KEY (m_id) REFERENCES manufacturer(m_id);

-- item_detail id -----------------------
-- i_id
ALTER TABLE item_detail DROP CONSTRAINT id_i_id_FK;

ALTER TABLE item_detail
ADD CONSTRAINT id_i_id_FK FOREIGN KEY (i_id) REFERENCES item(i_id);

-- item_price ip -------------------------
-- i_id
ALTER TABLE item_price DROP CONSTRAINT ip_i_id_FK;

ALTER TABLE item_price
ADD CONSTRAINT ip_i_id_FK FOREIGN KEY (i_id) REFERENCES item(i_id);

-- item_meta im ---------------------------
-- i_id
ALTER TABLE item_meta DROP CONSTRAINT im_i_id_FK;

ALTER TABLE item_meta
ADD CONSTRAINT im_i_id_FK FOREIGN KEY (i_id) REFERENCES item(i_id);

-- orders_item oi -------------------------
-- i_id
ALTER TABLE orders_item DROP CONSTRAINT oi_i_id_FK;

ALTER TABLE orders_item
ADD CONSTRAINT oi_i_id_FK FOREIGN KEY (i_id) REFERENCES item(i_id);

-- o_id
ALTER TABLE orders_item DROP CONSTRAINT oi_o_id_FK;

ALTER TABLE orders_item
ADD CONSTRAINT oi_o_id_FK FOREIGN KEY (o_id) REFERENCES orders(o_id);

-- orders o -------------------------------
-- p_id
ALTER TABLE orders DROP CONSTRAINT o_p_id_FK;

ALTER TABLE orders
ADD CONSTRAINT o_p_id_FK FOREIGN KEY (p_id) REFERENCES people(p_id);

-- orders_transactions otx ----------------
-- o_id
ALTER TABLE orders_transactions DROP CONSTRAINT otx_o_id_FK;

ALTER TABLE orders_transactions
ADD CONSTRAINT otx_o_id_FK FOREIGN KEY (o_id) REFERENCES orders(o_id);

-- t_id
ALTER TABLE orders_transactions DROP CONSTRAINT otx_t_id_FK;

ALTER TABLE orders_transactions
ADD CONSTRAINT otx_t_id_FK FOREIGN KEY (t_id) REFERENCES transactions(t_id);

-- p_id
ALTER TABLE orders_transactions DROP CONSTRAINT otx_p_id_FK;

ALTER TABLE orders_transactions
ADD CONSTRAINT otx_p_id_FK FOREIGN KEY (p_id) REFERENCES people(p_id);


-- Unique Key UK ----------------------------------------------------
ALTER TABLE people DROP CONSTRAINT p_email_UK;
ALTER TABLE people ADD CONSTRAINT p_email_UK UNIQUE (email);

-- Check Constraint
ALTER TABLE people DROP CONSTRAINT p_addr_ph_email_CK;
ALTER TABLE people ADD CONSTRAINT p_addr_ph_email_CK CHECK (
addr IS NOT NULL OR ph_cell IS NOT NULL OR email IS NOT NULL
);

